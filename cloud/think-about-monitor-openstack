虽然一些事可以做，但是否有更优的处理方式

关于
如何监控消息队列
如何优化运维工作

首先openstack是有一个instance_faults表有
错误信息，
他是通过捕获compute.manager入口的所有异常，并
发送给消息队列，来处理的。
其实能解决一些问题。

监控请求的所有操纵流程
重写openstack异常处理机制
对所有new的openstack异常发送traceback到
日志队列，日志listener接受异常，持久化

每一个rest请求生成一个job id放入
context中，并持久化一条记录到数据库
当如果任何job发生错误，把这个exception的traceback
和异常发生的主机，job id，locals()发给log队列
listener接受消息，并把对应信息job返回update对应记录

对于非job异常，则以系统异常返回。分为一类存放。

这个就要求，openstack的所有异常，要重写基类（或用装饰器封装一层），
并需要对所有new的对象，传递额外参数。


另一种方法，对所有模块的入口（rest api层，api方法层，消息接受层manager）封装，加decorator，捕获所有异常，重新上抛，并加以消息发送。但这也需要，所有异常都必须，在入口层捕获，不能在其他各实现层加以捕获处理。

这样对运维来说，问题就是查看所有错误的job，并加以处理。由于
节点信息，上下文变量都有了，对于troubleshooting来说就相对容易了。


其实也可以作为事件警告来用。
或是分析，自动处理来用。

另一个问题
如何trace整个任务流
比如创建虚拟机，当前job停留在那一步，那一行代码，
每一个job是否可以对应一个rest api接口
是否有使用 memcache的可能，对一些临时数据，减轻数据库的读写压力。
