虽然一些事可以做，但是否有更优的处理方式

关于
如何监控消息队列
如何优化运维工作

首先openstack是有一个instance_faults表有
错误信息，
他是通过捕获compute.manager入口的大多数方法异常，并
发送给消息队列，来处理的。
其实能解决一些问题。

监控请求的所有操纵流程
重写openstack异常处理机制
对所有new的openstack异常发送traceback到
日志队列，日志listener接受异常，持久化

每一个rest请求生成一个job id放入
context中，在任务流转过程中，
当如果发生错误，把这个exception的traceback
和异常发生的主机，job id，locals()发给log队列,
listener接受消息，并把对应信息job返回update对应记录

对于非job异常，则以系统异常返回。分为一类存放。

这个就要求，openstack的所有异常，要重写基类（或用装饰器封装一层），
并需要对所有new的对象，传递额外参数。


另一种方法，对所有模块的入口（rest api层，api方法层，消息接受层manager）封装，加decorator，捕获所有异常，重新上抛，并加以消息发送。但这也需要，所有异常都必须，在入口层捕获，不能在其他各实现层加以捕获处理。
: 目前有按此方法来做，工作量没有想象的大，主要是修改context类，如何写decorator。在nova中，绝大多数一场都会向上抛到入口处，统一捕获。
  所以，好的设计，和编码，方便不少工作。上下文也会在消息队列里传递，具体可以查看to_dict方法，和amqp里面的还原方式。

这样对运维来说，问题就是查看所有错误的job，并加以处理。由于
节点信息，上下文变量都有了，对于troubleshooting来说就相对容易了。


其实也可以作为事件警告来用。
或是分析，自动处理来用。

